// AUTOGENERATED FILE: DO NOT EDIT (idlc v0.2.3)
#pragma once

#include <stdint.h>
#include "object.h"

typedef Object ICredentials;

#define ICredentials_ERROR_NOT_FOUND INT32_C(10)
#define ICredentials_ERROR_NAME_SIZE INT32_C(11)
#define ICredentials_ERROR_VALUE_SIZE INT32_C(12)

#define ICredentials_OP_getPropertyByIndex 0
#define ICredentials_OP_getValueByName 1

static inline int32_t
ICredentials_release(Object self)
{
    return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
ICredentials_retain(Object self)
{
    return Object_invoke(self, Object_OP_retain, 0, 0);
}

/*
*
*   Gets the name of a property, given its position in the sequence of
*   properties.
*
*   @param[in]  index  A (zero-based) index into the set of properties.
*   @param[out] name   Property name, including a terminating zero byte.
*   @param[out] value  Property value, including a terminating zero byte.
*
*   @return
*   Object_OK -- Function returned successfully. \n
*   ICredentials_ERROR_NAME_SIZE -- Supplied buffer not large enough to
*                                   contain the name. \n
*   ICredentials_ERROR_VALUE_SIZE -- Supplied buffer not large enough to
*                                    contain the value. \n
*   ICredentials_ERROR_NOT_FOUND -- No properties at given index.
*
*/
static inline int32_t ICredentials_getPropertyByIndex(Object self, uint32_t index_val, void *name_ptr, size_t name_len, size_t *name_lenout, void *value_ptr, size_t value_len, size_t *value_lenout)
{
    ObjectArg a[] = {
        {.b = (ObjectBuf) { &index_val, sizeof(uint32_t) } },
        {.b = (ObjectBuf) { name_ptr, name_len * sizeof(uint8_t) } },
        {.b = (ObjectBuf) { value_ptr, value_len * sizeof(uint8_t) } },
    };

    int32_t result = Object_invoke(self, ICredentials_OP_getPropertyByIndex, a, ObjectCounts_pack(1, 2, 0, 0));

    *name_lenout = a[1].b.size / sizeof(uint8_t);
    *value_lenout = a[2].b.size / sizeof(uint8_t);
    return result;
}

/*
*
*   Returns a property value, given a name.
*
*   Note that <tt>name</tt> and <tt>value</tt> are buffer types, not strings.
*   The <tt>name</tt> buffer does not contain any null terminating character.
*   <tt>name</tt> length should be passed as the size of the buffer
*   if <tt>name</tt> is a zero-terminated string.
*
*   However, the <tt>value</tt> buffer will be populated with a
*   terminating null byte and the resulting output length will be set to
*   size, including the terminating null.
*
*   @param[in]  name   Property name.
*   @param[out] value  Property value, including a terminating zero byte.
*
*   @return
*   Object_OK -- Function returned successfully. \n
*   ICredentials_ERROR_VALUE_SIZE -- Supplied buffer not large enough to
*                                    contain value. \n
*   ICredentials_ERROR_NOT_FOUND -- No properties found with given name.
*
*/
static inline int32_t ICredentials_getValueByName(Object self, const void *name_ptr, size_t name_len, void *value_ptr, size_t value_len, size_t *value_lenout)
{
    ObjectArg a[] = {
        {.bi = (ObjectBufIn) { name_ptr, name_len * sizeof(uint8_t) } },
        {.b = (ObjectBuf) { value_ptr, value_len * sizeof(uint8_t) } },
    };

    int32_t result = Object_invoke(self, ICredentials_OP_getValueByName, a, ObjectCounts_pack(1, 1, 0, 0));

    *value_lenout = a[1].b.size / sizeof(uint8_t);
    return result;
}

